<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Brauereienlauf - Streckensimulator</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" type="image/svg+xml" href="icons/brauereienlauf_gestaltungselemente_maennchen_beigea_rgb.svg">
<link rel="apple-touch-icon" sizes="180x180" href="icons/brauereienlauf_gestaltungselemente_maennchen_beigea_rgb.svg">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
<style>
/* --- Global --- */
/* Grundlayout und Schriftart der Seite */
body { 
  margin: 0; 
  font-family: 'Inter', sans-serif; 
  display: flex; 
  height: 100vh; 
  overflow: hidden; 
}

/* --- Sidebar --- */
/* Layout, Hintergrund, Scroll und Schatten */
#sidebar { 
  width: 300px; 
  background: #FCF6EE; 
  color: #333; 
  padding: 10px; 
  box-shadow: 2px 0 5px rgba(0,0,0,0.1); 
  display: flex; 
  flex-direction: column; 
  gap: 10px; 
  overflow-y: auto; 
  z-index: 1000; 
}

/* Logo Bereich oben in der Sidebar */
#sidebarLogo { 
  background: #212121; 
  text-align: center; 
  margin-bottom: 10px; 
  padding: 10px; 
}
#sidebarLogo img { 
  max-width: 80%; 
  height: auto; 
  display: block; 
  margin: 0 auto; 
}

/* Farbquadrat und Delete-Button im Track Header */
.colorIndicator,
.track-header .deleteTrackBtn {
  width: 24px;
  height: 24px;
  border-radius: 4px;
  border: 1px solid #999;      
  display: flex;
  align-items: center;
  justify-content: center;
  margin-left: 5px;            
  box-sizing: border-box;
}

/* Delete-Button spezifisches Styling */
.track-header .deleteTrackBtn {
  background: #FF6600;
  color: #fff;
  border: 1px solid #999;
  font-weight: bold;
  font-size: 14px;
  line-height: 1;
  margin: 0;
  padding: 0;
  cursor: pointer;
}
.track-header .deleteTrackBtn:hover {
  background: #cc5200;
}

/* --- Track Header & Name --- */
/* Allgemeines Layout und Styling für Track Header */
.track-header { 
  display: flex; 
  align-items: center; 
  justify-content: center; /* Zentriert horizontal */
  gap: 8px; /* Abstand zwischen Farbe & Button */
  cursor: default; 
  padding: 6px 10px; 
  font-weight: bold; 
  background: #DED0BA; 
  border-bottom: 1px solid #ccc; 
  user-select: none; 
  border-radius: 6px; 
  color: #000; 
}

/* Hover-Effekte für Track Header */
.track-header .toggleSymbol { color: #000; }
.track-header:hover { background: #7664AA; }
.track-header:hover .toggleSymbol { color: #fff; }
.track-header:hover .trackName:not(:focus) { color: #fff; }

/* Track Name Eingabefeld */
.trackName { 
  flex: 1; 
  padding: 2px 4px; 
  border-radius: 4px; 
  background: transparent; 
  color: #000; 
}
.trackName:focus { 
  background: white; 
  color: #000; 
  outline: 2px solid #FF6600; 
}

/* Standard Button Styling */
button { 
  background: #FF6600; 
  color: white; 
  border: none; 
  border-radius: 4px; 
  padding: 6px 10px; 
  cursor: pointer; 
  margin-top: 6px; 
}
button:hover { background: #cc5200; }

/* --- Track Body / Form Labels & Inputs --- */
.track-body { 
  display: none; 
  padding: 8px 10px; 
}
.track-body label { 
  display: block; 
  font-size: 13px; 
  margin-top: 4px; 
}

/* Inputfelder Styling */
input[type="file"],
input[type="time"],
input[type="text"],
input[type="color"] {
  width: 100%;
  font-size: 14px;
  box-sizing: border-box;
}

/* --- Map / Slider --- */
#map { 
  flex: 1; 
  position: relative; 
  z-index: 0; 
}

/* --- Slider Styling --- */
#sliderContainer {
  position: absolute;
  bottom: 0;
  left: 321px;
  right: 0;
  background: #FCF6EE;
  padding: 10px;
  box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
  display: flex;
  align-items: center;
  gap: 10px;
  z-index: 2000;
}

#timeSlider {
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 6px;
  border-radius: 5px;
  outline: none;
  cursor: pointer;
  --slider-progress: 0%;
}

/* Chrome, Edge, Safari */
#timeSlider::-webkit-slider-runnable-track {
  height: 6px;
  border-radius: 5px;
  background: linear-gradient(to right, #7664AA var(--slider-progress), #DED0BA var(--slider-progress));
}
#timeSlider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #7664AA;
  border: 2px solid #FCF6EE;
  cursor: pointer;
  margin-top: -6px;
  transition: background 0.2s;
}
#timeSlider::-webkit-slider-thumb:hover { background: #5d4d8a; }

/* Firefox */
#timeSlider::-moz-range-track {
  background: #DED0BA;
  height: 6px;
  border-radius: 5px;
}
#timeSlider::-moz-range-progress {
  background: #7664AA;
  height: 6px;
  border-radius: 5px;
}
#timeSlider::-moz-range-thumb {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #7664AA;
  border: 2px solid #FCF6EE;
  cursor: pointer;
  transition: background 0.2s;
}
#timeSlider::-moz-range-thumb:hover { background: #5d4d8a; }

/* Zeit Label Styling */
#timeLabel { min-width: 80px; font-weight: bold; }

/* --- Leaflet Popups / Tooltips --- */
.leaflet-popup-content, 
.leaflet-tooltip { font-family: 'Inter', sans-serif; }

/* --- Optional: Alle Texte im Akkordeon und Sidebar Input/Labels --- */
.track-body * { font-family: 'Inter', sans-serif; }

/* Monospaced Zahlen in Inputs für bessere Lesbarkeit */
input[type="time"],
input[type="text"] { font-variant-numeric: tabular-nums; }
</style>
</head>
<body>

<div id="sidebar">
  <div id="sidebarLogo"><img src="icons/brauereienlauf-sued-logo.svg" alt="Brauereienlauf Logo"></div>
  <button id="addTrackBtn">Strecke hinzufügen</button>
  <div id="trackList"></div>
</div>

<div id="map"></div>

<div id="sliderContainer" style="display:none;">
  <input type="range" id="timeSlider" step="1" value="0" style="flex:1;">
  <span id="timeLabel">0:00</span>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/* ---------------------------
   Komplettes Script — 1:1 einfügen
   --------------------------- */

/* --- Karte & TileLayer --- */
const map = L.map('map').setView([49.9, 11.0], 12);
L.tileLayer('https://tile.openstreetmap.de/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '© OpenStreetMap-Mitwirkende'
}).addTo(map);

/* --- Icons --- */
const poiIcon = L.icon({ iconUrl: "icons/brauereienlauf_gestaltungselemente_maennchen_orange_rgb.svg", iconSize: [32,32], iconAnchor: [16,32], popupAnchor:[0,-32] });
const fastRunnerIcon = L.icon({ iconUrl: 'icons/brauereienlauf_gestaltungselemente_maennchen_gruen_rgb.svg', iconSize:[24,24], iconAnchor:[12,12], popupAnchor:[0,-12] });
const slowRunnerIcon = L.icon({ iconUrl: 'icons/brauereienlauf_gestaltungselemente_maennchen_orange_rgb.svg', iconSize:[24,24], iconAnchor:[12,12], popupAnchor:[0,-12] });

/* --- Globals --- */
let tracks = [];
const predefinedColors = ["#36542C","#FF6600","#7664AA","#212121","#DED0BA"];

/* --- Vordefinierte Strecken (Beispiel: Dateien im Ordner tracks/) --- */
const predefinedTracks = [
  { name:"Marathon", gpx:"tracks/M.gpx", startTime:"09:00", endTime:"16:00", fastPace:"03:30", slowPace:"09:00" },
  { name:"Halbmarathon", gpx:"tracks/HM.gpx", startTime:"11:00", endTime:"16:00", fastPace:"03:30", slowPace:"09:00" },
  { name:"10 km", gpx:"tracks/10k.gpx", startTime:"13:00", endTime:"16:00", fastPace:"03:30", slowPace:"09:00" },
  { name:"5 km", gpx:"tracks/5k.gpx", startTime:"13:30", endTime:"16:00", fastPace:"03:30", slowPace:"09:00" }
];

/* --- Vollständige POI-Liste (deine ursprünglichen POIs) --- */
const pois = [
  { name:"Start und Ziel", coords:[49.91086414586559,11.008078342287886], description:"Start und Zielbereich Tanzwiesen Litzendorf" },
  { name:"Brauerei Knoblach", coords:[49.92612562825621,11.006192497921718], description:"VP Brauerei Knoblach" },
  { name:"Brauerei Hölzlein", coords:[49.916433164362154,11.044922412182059], description:"VP Brauerei Hölzlein" },
  { name:"Brauerei Hönig", coords:[49.91854570624229,11.074094351945764], description:"VP Brauerei Hönig" },
  { name:"Brauerei Reh", coords:[49.9161925538902,11.050437379307478], description:"VP Brauerei Reh" },
  { name:"Brauerei Brandholz", coords:[49.89962613596553,11.031593469565935], description:"VP Brauerei Brandholz" },
  { name:"Landgasthof Büttel", coords:[49.88168405246902,11.01294568627889], description:"VP Landgasthof Büttel" },
  { name:"Gasthof Schiller", coords:[49.85771626727418,11.005281650520448], description:"VP Gasthof Schiller" },
  { name:"Schwanenkeller", coords:[49.851879458949746,10.97576017952508], description:"VP Schwanenkeller" },
  { name:"Brauerei Sauer", coords:[49.867831104839176,10.996951685705579], description:"VP Brauerei Sauer" },
  { name:"Regnitztaler Alm", coords:[49.88765943343463,10.981377141550507], description:"VP Regnitztaler Alm" },
  { name:"Kunigundenruh", coords:[49.903828616877256,10.960579372597097], description:"VP Kunigundenruh" }
];

/* --- Hilfsfunktionen --- */
function parsePace(p){ if(!p || p==="--:--") return null; const parts = p.split(":").map(Number); if(parts.length===1) return parts[0]*60; return parts[0]*60 + (parts[1]||0); }
function paceToMetersPerMinute(p){ const sec = parsePace(p); if(!sec) return null; return 1000/(sec/60); }
function timeToMinutes(t){ if(!t) return null; const [h,m] = t.split(":").map(Number); return h*60+m; }
function minutesToTime(m){ const h = Math.floor(m/60); const mm = m % 60; return `${h.toString().padStart(2,'0')}:${mm.toString().padStart(2,'0')}`; }
function totalLength(latlngs){ let d=0; for(let i=1;i<latlngs.length;i++) d += latlngs[i-1].distanceTo(latlngs[i]); return d; }
function interpolatePoint(latlngs,f){ if(!latlngs || latlngs.length===0) return null; if(f<=0) return latlngs[0]; if(f>=1) return latlngs[latlngs.length-1]; const total = totalLength(latlngs); let dist = 0; for(let i=1;i<latlngs.length;i++){ const seg = latlngs[i-1].distanceTo(latlngs[i]); if(dist+seg >= total*f){ const r = (total*f - dist)/seg; return L.latLng(latlngs[i-1].lat + (latlngs[i].lat - latlngs[i-1].lat)*r, latlngs[i-1].lng + (latlngs[i].lng - latlngs[i-1].lng)*r); } dist += seg; } return latlngs[latlngs.length-1]; }
function getSubsegment(latlngs,startFrac,endFrac){ if(!latlngs || latlngs.length===0) return []; const total = totalLength(latlngs); let dist = 0; const pts = []; let startAdded = false; for(let i=1;i<latlngs.length;i++){ const seg = latlngs[i-1].distanceTo(latlngs[i]); const segStart = dist; const segEnd = dist + seg; if(!startAdded && segEnd >= total*startFrac){ const r = (total*startFrac - segStart) / seg; pts.push(L.latLng(latlngs[i-1].lat + (latlngs[i].lat - latlngs[i-1].lat)*r, latlngs[i-1].lng + (latlngs[i].lng - latlngs[i-1].lng)*r)); startAdded = true; } if(segEnd > total*startFrac && segStart < total*endFrac) pts.push(latlngs[i]); if(segEnd >= total*endFrac){ const r = (total*endFrac - segStart) / seg; pts.push(L.latLng(latlngs[i-1].lat + (latlngs[i].lat - latlngs[i-1].lat)*r, latlngs[i-1].lng + (latlngs[i].lng - latlngs[i-1].lng)*r)); break; } dist += seg; } return pts; }

/* Glättung wie vorher */
function smoothPolyline(points, iterations = 2){
  for(let k=0;k<iterations;k++){
    const newPts=[];
    for(let i=0;i<points.length-1;i++){
      const p0=points[i], p1=points[i+1];
      newPts.push(L.latLng(0.75*p0.lat+0.25*p1.lat, 0.75*p0.lng+0.25*p1.lng));
      newPts.push(L.latLng(0.25*p0.lat+0.75*p1.lat, 0.25*p0.lng+0.75*p1.lng));
    }
    newPts.push(points[points.length-1]);
    points = newPts;
  }
  return points;
}

/* --- POIs auf Karte setzen (alle) --- */
pois.forEach(poi => {
  const marker = L.marker(poi.coords, { icon: poiIcon }).addTo(map);
  marker.bindTooltip(poi.name);
  marker.on("click", () => showDistancesToPoi(poi, marker));
});

/* --- POI-Popup-Logik (berücksichtigt alle geladenen Tracks) --- */
function showDistancesToPoi(poi, marker){
  const poiLatLng = L.latLng(poi.coords);
  let info = `<b>${poi.name}</b><br>${poi.description}<hr>`;
  let hasRunner = false;

  // Durch alle aktuell geladenen Tracks (vordefiniert + manuell)
  tracks.forEach(track => {
    if(!track || !track.trackPoints || !track.startTime || !track.endTime || !track.fastSpeed || !track.slowSpeed) return;

    // Name dynamisch aus Track-Objekt
    const trackName = track.name || "Neue Strecke";

    let closestDist = Infinity;
    let distAlong = 0;
    let distSoFar = 0;

    for(let i=1;i<track.trackPoints.length;i++){
      const p1 = track.trackPoints[i-1], p2 = track.trackPoints[i], seg = p1.distanceTo(p2);
      const d1 = p1.distanceTo(poiLatLng), d2 = p2.distanceTo(poiLatLng);
      const minD = Math.min(d1,d2);
      if(minD < closestDist){
        closestDist = minD;
        // approximate distAlong as distSoFar (good enough for popup ETA)
        distAlong = distSoFar;
      }
      distSoFar += seg;
    }

    if(closestDist > 40) return;
    hasRunner = true;
    const tStart = timeToMinutes(track.startTime);
    const fastArrival = minutesToTime(Math.floor(tStart + distAlong / track.fastSpeed));
    const slowArrival = minutesToTime(Math.floor(tStart + distAlong / track.slowSpeed));
    info += `<b>${trackName}</b><br>Erster Läufer: ${fastArrival} Uhr<br>Letzter Läufer: ${slowArrival} Uhr<br><br>`;
  });

  if(!hasRunner) info += "Keine Strecke führt hier vorbei.";
  marker._popup ? marker._popup.setContent(info) : marker.bindPopup(info);
  marker.openPopup();
}

/* --- Slider / Animation --- */
const slider = document.getElementById("timeSlider");
const timeLabel = document.getElementById("timeLabel");

function updateMarkers() {
  const currentMin = Number(slider.value);
  timeLabel.innerText = minutesToTime(currentMin);
  tracks.forEach(track => {
    if(!track.trackPoints || !track.startTime || !track.endTime || !track.fastSpeed || !track.slowSpeed){
      // entferne ggf. Marker/Segment wenn unvollständig
      ["fastMarker","slowMarker","redSegment"].forEach(k => { if(track[k]) { map.removeLayer(track[k]); track[k] = null; }});
      return;
    }
    const minsSinceStart = currentMin - timeToMinutes(track.startTime);
    const fastDist = Math.max(Math.min(track.fastSpeed * minsSinceStart, track.totalDist), 0);
    const slowDist = Math.max(Math.min(track.slowSpeed * minsSinceStart, track.totalDist), 0);
    const fastFrac = track.totalDist > 0 ? fastDist / track.totalDist : 0;
    const slowFrac = track.totalDist > 0 ? slowDist / track.totalDist : 0;
    const fastPos = interpolatePoint(track.trackPoints, fastFrac);
    const slowPos = interpolatePoint(track.trackPoints, slowFrac);
    if(track.fastMarker) track.fastMarker.setLatLng(fastPos);
    if(track.slowMarker) track.slowMarker.setLatLng(slowPos);

    // roter Abschnitt
    if(track.redSegment){ map.removeLayer(track.redSegment); track.redSegment = null; }
    const subPoints = getSubsegment(track.trackPoints, Math.min(fastFrac, slowFrac), Math.max(fastFrac, slowFrac));
    if(subPoints.length > 1){
      const smooth = smoothPolyline(subPoints, 2);
      track.redSegment = L.polyline(smooth, { color:"red", weight:6, opacity:0.8 }).addTo(map);
    }
  });
}

function updateSliderRange(){
  const valid = tracks.filter(t => t.startTime && t.endTime);
  if(valid.length === 0){ document.getElementById("sliderContainer").style.display = "none"; return; }
  const starts = valid.map(t => timeToMinutes(t.startTime));
  const ends = valid.map(t => timeToMinutes(t.endTime));
  slider.min = Math.min(...starts);
  slider.max = Math.max(...ends);
  slider.value = slider.min;
  timeLabel.innerText = minutesToTime(slider.value);
  document.getElementById("sliderContainer").style.display = "flex";
  updateMarkers();
}
slider.addEventListener("input", () => requestAnimationFrame(updateMarkers));

/* --- Pace Mask & Trackname Init (wie vorher) --- */
function initPaceField(input){
  if(!input) return;
  input.value = input.value || "--:--";
  input.addEventListener("focus", ()=>{ if(input.value === "--:--") input.value = ""; });
  input.addEventListener("blur", ()=>{ if(input.value.trim() === "") input.value = "--:--"; });
  input.addEventListener("input", ()=>{ let val = input.value.replace(/\D/g,'').slice(0,4); if(val.length>2) val = val.slice(0,2)+":"+val.slice(2); input.value = val; });
}
function initTrackName(trackNameEl){
  const DEFAULT = "Neue Strecke";
  trackNameEl.innerText = trackNameEl.innerText || DEFAULT;
  trackNameEl.addEventListener("focus", ()=>{ if(trackNameEl.innerText === DEFAULT) { trackNameEl.innerText = ""; const r = document.createRange(); const s = window.getSelection(); r.setStart(trackNameEl,0); r.collapse(true); s.removeAllRanges(); s.addRange(r); }});
  trackNameEl.addEventListener("blur", ()=>{ if(trackNameEl.innerText.trim() === "") trackNameEl.innerText = DEFAULT; if(trackNameEl.parentElement.trackObj) trackNameEl.parentElement.trackObj.name = trackNameEl.innerText.trim(); });
  trackNameEl.addEventListener("keydown", (e)=>{ if(e.key === "Enter"){ e.preventDefault(); trackNameEl.blur(); }});
  trackNameEl.addEventListener("input", ()=>{ if(trackNameEl.parentElement.trackObj) trackNameEl.parentElement.trackObj.name = trackNameEl.innerText.trim(); });
}

/* --- Reset-Funktion für eine Sidebar-Zeile --- */
function resetTrackSettings(trackDiv){
  const start = trackDiv.querySelector(".startTime");
  const end = trackDiv.querySelector(".endTime");
  const fast = trackDiv.querySelector(".fastPace");
  const slow = trackDiv.querySelector(".slowPace");
  if(start) start.value = "";
  if(end) end.value = "";
  if(fast) fast.value = "--:--";
  if(slow) slow.value = "--:--";
  if(trackDiv.trackObj){
    trackDiv.trackObj.startTime = null;
    trackDiv.trackObj.endTime = null;
    trackDiv.trackObj.fastSpeed = null;
    trackDiv.trackObj.slowSpeed = null;
    // Marker zurücksetzen
    if(trackDiv.trackObj.trackPoints?.length){
      const p = trackDiv.trackObj.trackPoints[0];
      if(trackDiv.trackObj.fastMarker) trackDiv.trackObj.fastMarker.setLatLng(p);
      if(trackDiv.trackObj.slowMarker) trackDiv.trackObj.slowMarker.setLatLng(p);
    }
  }
  updateSliderRange();
}

/* --- Funktion: GPX laden (für predefined oder manuell) --- */
function loadGpxIntoTrackDiv(gpxPath, trackDiv, useFile=false, fileContent=null){
  // Wenn useFile true, fileContent enthält den GPX-Text bereits (manueller Upload)
  const doParse = (gpxText) => {
    const xml = new DOMParser().parseFromString(gpxText, "text/xml");
    // robust: trkpt, rtept, wpt
    let nodes = xml.getElementsByTagName("trkpt");
    if(!nodes.length) nodes = xml.getElementsByTagName("rtept");
    if(!nodes.length) nodes = xml.getElementsByTagName("wpt");
    if(!nodes.length){ console.warn("Keine Trackpunkte gefunden in", gpxPath); return; }
    const latlngs = Array.from(nodes).map(n => L.latLng(parseFloat(n.getAttribute("lat")), parseFloat(n.getAttribute("lon"))));
    if(!latlngs.length) { console.warn("Keine gültigen Koordinaten"); return; }

    const color = trackDiv.querySelector(".trackColor").value;
    const fastPaceVal = trackDiv.querySelector(".fastPace").value;
    const slowPaceVal = trackDiv.querySelector(".slowPace").value;

    const trackObj = {
      id: Date.now() + Math.random(),
      name: trackDiv.querySelector(".trackName").innerText.trim(),
      trackPoints: latlngs,
      totalDist: totalLength(latlngs),
      color,
      startTime: trackDiv.querySelector(".startTime").value || null,
      endTime: trackDiv.querySelector(".endTime").value || null,
      fastSpeed: paceToMetersPerMinute(fastPaceVal),
      slowSpeed: paceToMetersPerMinute(slowPaceVal)
    };

    trackObj.fullTrackLayer = L.polyline(latlngs, { color, weight: 4 }).addTo(map);
    trackObj.fastMarker = L.marker(latlngs[0], { icon: fastRunnerIcon }).addTo(map);
    trackObj.slowMarker = L.marker(latlngs[0], { icon: slowRunnerIcon }).addTo(map);

    trackDiv.trackObj = trackObj;
    tracks.push(trackObj);
    updateSliderRange();
    map.fitBounds(trackObj.fullTrackLayer.getBounds());
  };

  if(useFile && fileContent !== null){
    doParse(fileContent);
  } else {
    fetch(gpxPath).then(r => r.text()).then(doParse).catch(e => console.error("Fehler beim Laden GPX:", e));
  }
}

/* --- Add Track Form (wird für predefined und manuell genutzt) --- */
function addTrackForm(predef){
  const trackList = document.getElementById("trackList");
  const trackDiv = document.createElement("div");
  trackDiv.className = "track";

  const idx = trackList.querySelectorAll(".track").length;
  const color = predefinedColors[idx % predefinedColors.length];

  trackDiv.innerHTML = `
    <div class="track-header">
      <span class="toggleSymbol">&#9660;</span>
      <span class="trackName" contenteditable="true">${predef?.name || "Neue Strecke"}</span>
      <div class="colorIndicator" style="background:${color}"></div>
      <button class="deleteTrackBtn">X</button>
    </div>
    <div class="track-body">
      <label>Trackfarbe: <input type="color" class="trackColor" value="${color}"></label>
      <label>Startzeit: <input type="time" class="startTime" value="${predef?.startTime||''}"></label>
      <label>Zielzeit: <input type="time" class="endTime" value="${predef?.endTime||''}"></label>
      <label>Schnellste Pace (min/km): <input type="text" class="fastPace" maxlength="5" value="${predef?.fastPace||'--:--'}"></label>
      <label>Langsamste Pace (min/km): <input type="text" class="slowPace" maxlength="5" value="${predef?.slowPace||'--:--'}"></label>
      <label>GPX-Datei: <input type="file" class="gpxFile" accept=".gpx"></label>
      <button class="loadTrackBtn" style="background:#FF6600;color:white;border:none;border-radius:4px;margin-top:6px;">Track laden</button>
      <button class="resetBtn" style="background:#eee;color:#000;border:1px solid #ccc;border-radius:4px;margin-top:6px;">Zurücksetzen</button>
    </div>
  `;

  trackList.appendChild(trackDiv);

  const header = trackDiv.querySelector(".track-header");
  const body = trackDiv.querySelector(".track-body");
  const toggle = header.querySelector(".toggleSymbol");
  const delBtn = header.querySelector(".deleteTrackBtn");
  const colorPicker = trackDiv.querySelector(".trackColor");
  const colorIndicator = trackDiv.querySelector(".colorIndicator");
  const gpxFileInput = trackDiv.querySelector(".gpxFile");
  const loadBtn = trackDiv.querySelector(".loadTrackBtn");
  const resetBtn = trackDiv.querySelector(".resetBtn");

  // init helpers
  initTrackName(trackDiv.querySelector(".trackName"));
  initPaceField(trackDiv.querySelector(".fastPace"));
  initPaceField(trackDiv.querySelector(".slowPace"));

  // accordion toggle
  toggle.addEventListener("click", (e) => { e.stopPropagation(); const open = trackDiv.classList.toggle("open"); body.style.display = open ? "block" : "none"; toggle.innerHTML = open ? "&#9660;" : "&#9654;"; });
  trackDiv.classList.add("open"); body.style.display = "block"; toggle.innerHTML = "&#9660;";

  // delete
  delBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    if(trackDiv.trackObj){
      ["fullTrackLayer","redSegment","fastMarker","slowMarker"].forEach(k => { if(trackDiv.trackObj[k]) map.removeLayer(trackDiv.trackObj[k]); });
      tracks = tracks.filter(t => t.id !== trackDiv.trackObj.id);
    }
    trackDiv.remove();
    updateSliderRange();
  });

  // color change
  colorPicker.addEventListener("input", () => {
    colorIndicator.style.background = colorPicker.value;
    if(trackDiv.trackObj?.fullTrackLayer) trackDiv.trackObj.fullTrackLayer.setStyle({ color: colorPicker.value });
  });

  // reset button
  resetBtn.addEventListener("click", (e) => { e.preventDefault(); resetTrackSettings(trackDiv); });

  // load button (manuell von Datei)
  loadBtn.addEventListener("click", (e) => {
    e.preventDefault();
    const file = gpxFileInput.files[0];
    if(!file) return alert("Bitte GPX-Datei auswählen.");
    const reader = new FileReader();
    reader.onload = (ev) => {
      loadGpxIntoTrackDiv(null, trackDiv, true, ev.target.result);
    };
    reader.readAsText(file);
  });

  return trackDiv;
}

/* --- Init: predefinied laden + Add button hookup --- */
window.addEventListener("DOMContentLoaded", () => {
  // predefined tracks -> create sidebar rows and auto-load GPX
  predefinedTracks.forEach(pt => {
    const td = addTrackForm(pt);
    if(pt.gpx) loadGpxIntoTrackDiv(pt.gpx, td, false, null);
  });

  // manuell hinzufügen button
  document.getElementById("addTrackBtn").addEventListener("click", () => addTrackForm());
});
</script>

</body>
</html>

