<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Brauereienlauf - Streckensimulator</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
<style>
/* --- Global --- */
body { 
  margin: 0; 
  font-family: 'Inter', sans-serif; 
  display: flex; 
  height: 100vh; 
  overflow: hidden; 
}

/* Hamburger Menu Button */
#hamburger {
  display: none;
  position: fixed;
  top: 10px;
  right: 10px;
  z-index: 1001;
  background: #FF6600;
  border: none;
  color: white;
  font-size: 24px;
  width: 44px;
  height: 44px;
  border-radius: 4px;
  cursor: pointer;
  transition: background 0.2s ease;
}

#hamburger:hover {
  background: #cc5200;
}

/* Mobile Styles */
@media (max-width: 1024px) {
  body {
    flex-direction: column;
  }

  #hamburger {
    display: block;
  }

  #sidebar {
    position: fixed;
    left: -340px;
    top: 0;
    width: 300px;
    height: 100vh;
    transition: left 0.3s ease;
    z-index: 1000;
  }

  #sidebar.open {
    left: 0;
  }

  #map {
    width: 100% !important;
    height: 100%;
    flex: 1;
  }

  #sliderContainer {
    left: 0 !important;
    height: auto;
    padding: 15px;
  }

  #timeSlider {
    height: 8px;
  }

  #timeSlider::-webkit-slider-thumb {
    width: 24px;
    height: 24px;
    margin-top: -8px;
  }

  #timeSlider::-moz-range-thumb {
    width: 24px;
    height: 24px;
  }

  #timeLabel {
    font-size: 16px;
  }
}

/* Desktop Styles */
@media (min-width: 1025px) {
  #hamburger {
    display: none;
  }

  #sidebar {
    position: relative;
    left: 0 !important;
  }
}

/* --- Sidebar --- */
#sidebar { 
  width: 300px; 
  background: #FCF6EE; 
  color: #333; 
  padding: 10px; 
  box-shadow: 2px 0 5px rgba(0,0,0,0.1); 
  display: flex; 
  flex-direction: column; 
  gap: 10px; 
  overflow-y: auto; 
  z-index: 1000; 
}

/* Custom Scrollbar */
#sidebar::-webkit-scrollbar {
  width: 8px;
}

#sidebar::-webkit-scrollbar-track {
  background: #FCF6EE;
}

#sidebar::-webkit-scrollbar-thumb {
  background: #DED0BA;
  border-radius: 4px;
}

#sidebar::-webkit-scrollbar-thumb:hover {
  background: #c9baa8;
}

/* Firefox Scrollbar */
#sidebar {
  scrollbar-color: #DED0BA #FCF6EE;
  scrollbar-width: thin;
}

#sidebarLogo { 
  background: #212121; 
  text-align: center; 
  margin-bottom: 10px; 
  padding: 10px; 
}
#sidebarLogo img { 
  max-width: 80%; 
  height: auto; 
  display: block; 
  margin: 0 auto; 
}

/* Track Abstand */
.track { 
  margin-bottom: 8px; 
}

/* Farbkreis und Delete-Button im Track Header */
.colorIndicator,
.track-header .deleteTrackBtn {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  border: 2px solid #FCF6EE;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  box-sizing: border-box;
}

/* Delete-Button spezifisches Styling */
.track-header .deleteTrackBtn {
  background: #FF6600;
  color: #fff;
  font-weight: bold;
  font-size: 16px;
  line-height: 1;
  padding: 0 !important;
  margin: 0 !important;
  margin-top: 0 !important;
  cursor: pointer;
  transition: background 0.2s;
}
.track-header .deleteTrackBtn:hover {
  background: #cc5200;
}

/* --- Track Header & Name --- */
.track-header { 
  display: flex; 
  align-items: center; 
  justify-content: flex-start;
  gap: 12px;
  cursor: default; 
  padding: 8px 12px;
  font-weight: bold; 
  background: #DED0BA; 
  border-bottom: 1px solid #ccc; 
  user-select: none; 
  border-radius: 6px; 
  color: #000;
  transition: background 0.2s ease;
}

.track-header .toggleSymbol { 
  color: #000;
  font-size: 16px;
  flex-shrink: 0;
  cursor: pointer;
}
.track-header:hover { background: #7664AA; }
.track-header:hover .toggleSymbol { color: #fff; }
.track-header:hover .trackName:not(:focus) { color: #fff; }

.trackName { 
  flex: 1; 
  padding: 4px 6px; 
  border-radius: 4px; 
  background: transparent; 
  color: #000;
  font-size: 14px;
  font-weight: bold;
  min-height: 20px;
}
.trackName:focus { 
  background: white; 
  color: #000; 
  outline: 2px solid #FF6600; 
}

/* Button Base Styles */
button { 
  background: #FF6600; 
  color: white; 
  border: none; 
  border-radius: 4px; 
  padding: 6px 10px; 
  cursor: pointer; 
  margin-top: 6px; 
  font-size: 13px;
  transition: background 0.2s ease;
}
button:hover { background: #cc5200; }

/* Strecke hinzufügen Button */
#addTrackBtn {
  font-size: 16px;
  font-weight: bold;
}

/* Primary Button (Track laden) */
.loadBtn {
  background: #FF6600;
}
.loadBtn:hover {
  background: #cc5200;
}

/* Secondary Button (Reset) */
.resetBtn {
  background: #7664AA;
  color: white;
}
.resetBtn:hover {
  background: #5d4d8a;
}

/* Loading Animation für LoadBtn */
@keyframes pulse {
  0% { opacity: 1; }
  50% { opacity: 0.6; }
  100% { opacity: 1; }
}

.loadBtn.loading {
  animation: pulse 1s ease-in-out infinite;
  pointer-events: none;
}

/* --- Track Body / Form Labels & Inputs --- */
.track-body { 
  display: none; 
  padding: 8px 10px;
  background: #f5ede5;
  border-radius: 0 0 6px 6px;
  margin-top: -1px;
  border: 2px solid #DED0BA;
  border-top: none;
}
.track-body label { 
  display: block; 
  font-size: 13px; 
  margin-top: 4px; 
}

input[type="file"],
input[type="time"],
input[type="text"],
input[type="color"] {
  width: 100%;
  font-size: 14px;
  box-sizing: border-box;
  font-family: 'Inter', sans-serif;
  padding: 6px 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: #fff;
  transition: border-color 0.2s ease, outline-color 0.2s ease;
}

input[type="file"]:focus,
input[type="time"]:focus,
input[type="text"]:focus,
input[type="color"]:focus {
  outline: 2px solid #FF6600;
  outline-offset: 2px;
  border-color: #FF6600;
}

/* --- Map / Slider --- */
#map { 
  flex: 1; 
  position: relative; 
  z-index: 0; 
}

/* --- Slider Styling --- */
#sliderContainer {
  position: absolute;
  bottom: 0;
  left: 321px;
  right: 0;
  background: #FCF6EE;
  padding: 10px;
  box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
  display: flex;
  align-items: center;
  gap: 10px;
  z-index: 2000;
}

#timeSlider {
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 6px;
  border-radius: 5px;
  outline: none;
  cursor: pointer;
  --slider-progress: 0%;
}

#timeSlider::-webkit-slider-runnable-track {
  height: 6px;
  border-radius: 5px;
  background: linear-gradient(to right, #7664AA var(--slider-progress), #DED0BA var(--slider-progress));
}
#timeSlider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #7664AA;
  border: 2px solid #FCF6EE;
  cursor: pointer;
  margin-top: -6px;
  transition: background 0.2s;
}
#timeSlider::-webkit-slider-thumb:hover { background: #5d4d8a; }

#timeSlider::-moz-range-track {
  background: #DED0BA;
  height: 6px;
  border-radius: 5px;
}
#timeSlider::-moz-range-progress {
  background: #7664AA;
  height: 6px;
  border-radius: 5px;
}
#timeSlider::-moz-range-thumb {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #7664AA;
  border: 2px solid #FCF6EE;
  cursor: pointer;
  transition: background 0.2s;
}
#timeSlider::-moz-range-thumb:hover { background: #5d4d8a; }

#timeLabel { min-width: 80px; font-weight: bold; }

.leaflet-popup-content, 
.leaflet-tooltip { font-family: 'Inter', sans-serif; }

.leaflet-popup-content {
  background: #FCF6EE !important;
  border-radius: 8px;
  padding-top: 50px !important;
  position: relative;
  color: #333 !important;
}

.leaflet-popup {
  margin-bottom: 0 !important;
}

.track-body * { font-family: 'Inter', sans-serif; }

input[type="time"],
input[type="text"] { font-variant-numeric: tabular-nums; }
</style>
</head>
<body>

<button id="hamburger">☰</button>

<div id="sidebar">
  <div id="sidebarLogo"><img src="icons/brauereienlauf-sued-logo.svg" alt="Brauereienlauf Logo"></div>
  <button id="addTrackBtn">Strecke hinzufügen</button>
  <div id="trackList"></div>
</div>

<div id="map"></div>

<div id="sliderContainer" style="display:none;">
  <input type="range" id="timeSlider" step="1" value="0" style="flex:1;">
  <span id="timeLabel">0:00</span>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const map = L.map('map').setView([49.9, 11.0],12);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ maxZoom:19, attribution:'© OpenStreetMap-Mitwirkende' }).addTo(map);

const timeSlider = document.getElementById('timeSlider');
if(timeSlider){
  const updateSliderColor = () => {
    const value = (timeSlider.value - timeSlider.min) / (timeSlider.max - timeSlider.min) * 100;
    timeSlider.style.setProperty('--slider-progress', `${value}%`);
  };
  timeSlider.addEventListener('input', updateSliderColor);
  updateSliderColor();
}

const pois = [
  { name:"Start und Ziel", coords:[49.91086414586559,11.008078342287886], description:"Start und Zielbereich Tanzwiesen Litzendorf", logo:"icons/Start.jpg" },
  { name:"Brauerei Knoblach", coords:[49.92612562825621,11.006192497921718], description:"VP Brauerei Knoblach", logo:"icons/Knoblach.jpg" },
  { name:"Brauerei Hölzlein", coords:[49.916433164362154,11.044922412182059], description:"VP Brauerei Hölzlein", logo:"icons/Hölzlein.jpg" },
  { name:"Brauerei Hönig", coords:[49.91854570624229,11.074094351945764], description:"VP Brauerei Hönig", logo:"icons/Hönig.png" },
  { name:"Brauerei Reh", coords:[49.9161925538902,11.050437379307478], description:"VP Brauerei Reh", logo:"icons/Reh.png" },
  { name:"Brauerei Brandholz", coords:[49.89962613596553,11.031593469565935], description:"VP Brauerei Brandholz", logo:"icons/Brandholz.jpg" },
  { name:"Landgasthof Büttel", coords:[49.88168405246902,11.01294568627889], description:"VP Landgasthof Büttel", logo:"icons/Büttel.jpg" },
  { name:"Gasthof Schiller", coords:[49.85771626727418,11.005281650520448], description:"VP Gasthof Schiller", logo:"icons/Schiller.jpg" },
  { name:"Schwanenkeller", coords:[49.851879458949746,10.97576017952508], description:"VP Schwanenkeller", logo:"icons/Hopfen.jpg" },
  { name:"Brauerei Sauer", coords:[49.867831104839176,10.996951685705579], description:"VP Brauerei Sauer", logo:"icons/Sauer.png" },
  { name:"Regnitztaler Alm", coords:[49.88765943343463, 10.981377141550507], description:"VP Regnitztaler Alm", logo:"icons/Hopfen.jpg" },
  { name:"Kunigundenruh", coords:[49.903828616877256,10.960579372597097], description:"VP Kunigundenruh", logo:"icons/Hopfen.jpg" }
];

const poiIcon = L.icon({
  iconUrl: "icons/brauereienlauf_gestaltungselemente_maennchen_orange_rgb.svg",
  iconSize: [32,32],
  iconAnchor: [16,32],
  popupAnchor: [0,-32]
});

const fastRunnerIcon = L.icon({
  iconUrl: 'icons/brauereienlauf_gestaltungselemente_maennchen_gruen_rgb.svg',
  iconSize: [24, 24],
  iconAnchor: [12, 12],
  popupAnchor: [0, -12]
});

const slowRunnerIcon = L.icon({
  iconUrl: 'icons/brauereienlauf_gestaltungselemente_maennchen_orange_rgb.svg',
  iconSize: [24, 24],
  iconAnchor: [12, 12],
  popupAnchor: [0, -12]
});

let tracks=[];
const predefinedColors=["#36542C","#FF6600","#7664AA","#212121","#DED0BA"];
let colorIndex=0;

const slider=document.getElementById("timeSlider");
const timeLabel=document.getElementById("timeLabel");

function parsePace(p){ if(!p || p==="--:--") return null; const parts=p.split(":").map(Number); if(parts.length===1) return parts[0]*60; return parts[0]*60+parts[1]; }
function paceToMetersPerMinute(p){ const sec=parsePace(p); if(sec===null||sec===0) return null; return 1000/(sec/60); }
function totalLength(latlngs){ let d=0; for(let i=1;i<latlngs.length;i++) d+=latlngs[i-1].distanceTo(latlngs[i]); return d; }
function interpolatePoint(latlngs,f){ if(!latlngs||latlngs.length===0) return null; if(f<=0) return latlngs[0]; if(f>=1) return latlngs[latlngs.length-1]; const total=totalLength(latlngs); let dist=0; for(let i=1;i<latlngs.length;i++){ const seg=latlngs[i-1].distanceTo(latlngs[i]); if(dist+seg>=total*f){ const r=(total*f-dist)/seg; return L.latLng(latlngs[i-1].lat+(latlngs[i].lat-latlngs[i-1].lat)*r, latlngs[i-1].lng+(latlngs[i].lng-latlngs[i-1].lng)*r); } dist+=seg; } return latlngs[latlngs.length-1]; }
function getSubsegment(latlngs,startFrac,endFrac){ if(!latlngs||latlngs.length===0) return []; const total=totalLength(latlngs); let dist=0; const pts=[]; let startAdded=false; for(let i=1;i<latlngs.length;i++){ const seg=latlngs[i-1].distanceTo(latlngs[i]); const segStart=dist; const segEnd=dist+seg; if(!startAdded && segEnd>=total*startFrac){ const r=(total*startFrac-segStart)/seg; pts.push(L.latLng(latlngs[i-1].lat+(latlngs[i].lat-latlngs[i-1].lat)*r, latlngs[i-1].lng+(latlngs[i].lng-latlngs[i-1].lng)*r)); startAdded=true; } if(segEnd>total*startFrac && segStart<total*endFrac) pts.push(latlngs[i]); if(segEnd>=total*endFrac){ const r=(total*endFrac-segStart)/seg; pts.push(L.latLng(latlngs[i-1].lat+(latlngs[i].lat-latlngs[i-1].lat)*r, latlngs[i-1].lng+(latlngs[i].lng-latlngs[i-1].lng)*r)); break; } dist+=seg; } return pts; }
function timeToMinutes(t){ if(!t) return null; const [h,m]=t.split(":").map(Number); return h*60+m; }
function minutesToTime(m){ const h=Math.floor(m/60); const mm=m%60; return `${h.toString().padStart(2,'0')}:${mm.toString().padStart(2,'0')}`; }

function showDistancesToPoi(poi, marker){
  const poiLatLng = L.latLng(poi.coords);
  const logoImg = poi.logo ? `<div style="text-align: center; margin-top: -50px; margin-bottom: 10px;"><img src="${poi.logo}" style="width: 60px; height: 60px; border-radius: 50%; border: 3px solid #DED0BA; background: #FCF6EE; box-shadow: 0 2px 8px rgba(0,0,0,0.15); object-fit: cover;"></div>` : '';
  let info = `${logoImg}<b>${poi.name}</b><br>${poi.description}<hr>`;
  let hasRunner = false;

  document.querySelectorAll("#trackList .track").forEach(trackDiv => {
    const track = trackDiv.trackObj;
    if(!track || !track.trackPoints || !track.startTime || !track.endTime || !track.fastSpeed || !track.slowSpeed) return;

    const trackNameEl = trackDiv.querySelector(".trackName");
    const trackName = trackNameEl ? trackNameEl.innerText.trim() || "Neue Strecke" : "Neue Strecke";

    let closestDist = Infinity;
    let distAlongTrack = 0;
    let distSoFar = 0;

    for(let i = 1; i < track.trackPoints.length; i++){
      const p1 = track.trackPoints[i-1], p2 = track.trackPoints[i], segDist = p1.distanceTo(p2);
      const minDist = Math.min(p1.distanceTo(poiLatLng), p2.distanceTo(poiLatLng));
      if(minDist < closestDist){
        closestDist = minDist;
        distAlongTrack = distSoFar + (minDist === p1.distanceTo(poiLatLng) ? 0 : segDist);
      }
      distSoFar += segDist;
    }

    if(closestDist > 40) return;
    hasRunner = true;

    const tStart = timeToMinutes(track.startTime);
    const tEnd = timeToMinutes(track.endTime);
    
    // Für "Start und Ziel" POI: Endzeiten berechnen (Startzeit + gesamte Strecke / Pace)
    let fastArrival, slowArrival;
    if(poi.name === "Start und Ziel") {
      const fastEndTime = minutesToTime(Math.floor(tStart + track.totalDist / track.fastSpeed));
      const slowEndTime = minutesToTime(Math.floor(tStart + track.totalDist / track.slowSpeed));
      fastArrival = fastEndTime;
      slowArrival = slowEndTime;
      info += `<b>${trackName}</b><br>Ankunft schnellster: ${fastArrival} Uhr<br>Ankunft langsamster: ${slowArrival} Uhr<br><br>`;
    } else {
      fastArrival = minutesToTime(Math.floor(tStart + distAlongTrack / track.fastSpeed));
      slowArrival = minutesToTime(Math.floor(tStart + distAlongTrack / track.slowSpeed));
      info += `<b>${trackName}</b><br>Erster Läufer: ${fastArrival} Uhr<br>Letzter Läufer: ${slowArrival} Uhr<br><br>`;
    }
  });

  if(!hasRunner) info += "Keine Strecke führt hier vorbei.";

  if(!marker._popup) marker._popup = L.popup({maxWidth:250});
  marker._popup.setLatLng(marker.getLatLng()).setContent(info).openOn(map);
}

pois.forEach(poi=>{
  const marker=L.marker(poi.coords,{icon:poiIcon}).addTo(map);
  marker.bindTooltip(poi.name);
  marker.on("click",()=>showDistancesToPoi(poi,marker));
});

function updateSliderRange(){
  const validTracks=tracks.filter(t=>t.startTime && t.endTime);
  if(validTracks.length===0){ document.getElementById("sliderContainer").style.display="none"; return; }
  const startTimes=validTracks.map(t=>timeToMinutes(t.startTime));
  const endTimes=validTracks.map(t=>timeToMinutes(t.endTime));
  slider.min=Math.min(...startTimes);
  slider.max=Math.max(...endTimes);
  slider.value=slider.min;
  timeLabel.innerText=minutesToTime(slider.value);
  document.getElementById("sliderContainer").style.display="flex";
  updateMarkers();
}
let animationFrame=null;
slider.addEventListener("input",()=>{ if(animationFrame) cancelAnimationFrame(animationFrame); animationFrame=requestAnimationFrame(updateMarkers); });

function smoothPolyline(points, iterations = 2) {
  for (let k = 0; k < iterations; k++) {
    const newPoints = [];
    for (let i = 0; i < points.length - 1; i++) {
      const p0 = points[i];
      const p1 = points[i + 1];
      newPoints.push(L.latLng(
        0.75 * p0.lat + 0.25 * p1.lat,
        0.75 * p0.lng + 0.25 * p1.lng
      ));
      newPoints.push(L.latLng(
        0.25 * p0.lat + 0.75 * p1.lat,
        0.25 * p0.lng + 0.75 * p1.lng
      ));
    }
    newPoints.push(points[points.length - 1]);
    points = newPoints;
  }
  return points;
}

function updateMarkers() {
  const currentMin = Number(slider.value);
  timeLabel.innerText = minutesToTime(currentMin);

  tracks.forEach(track => {
    if (!track.trackPoints || !track.startTime || !track.endTime || !track.fastSpeed || !track.slowSpeed) {
      ["fastMarker", "slowMarker", "redSegment"].forEach(k => {
        if (track[k]) { map.removeLayer(track[k]); track[k] = null; }
      });
      return;
    }

    const minsSinceStart = currentMin - timeToMinutes(track.startTime);
    const fastDist = Math.max(Math.min(track.fastSpeed * minsSinceStart, track.totalDist), 0);
    const slowDist = Math.max(Math.min(track.slowSpeed * minsSinceStart, track.totalDist), 0);

    const fastFrac = track.totalDist > 0 ? fastDist / track.totalDist : 0;
    const slowFrac = track.totalDist > 0 ? slowDist / track.totalDist : 0;

    const fastPos = interpolatePoint(track.trackPoints, fastFrac);
    const slowPos = interpolatePoint(track.trackPoints, slowFrac);

    if (track.fastMarker) track.fastMarker.setLatLng(fastPos);
    if (track.slowMarker) track.slowMarker.setLatLng(slowPos);

    if (track.redSegment) {
      map.removeLayer(track.redSegment);
      track.redSegment = null;
    }

    const subPoints = getSubsegment(
      track.trackPoints,
      Math.min(fastFrac, slowFrac),
      Math.max(fastFrac, slowFrac)
    );

    if (subPoints.length > 1) {
      const smoothPoints = smoothPolyline(subPoints, 2);
      track.redSegment = L.polyline(smoothPoints, {
        color: "red",
        weight: 6,
        opacity: 0.8
      }).addTo(map);
    }
  });
}

function initPaceField(input){
  input.value="--:--";
  input.addEventListener("focus",()=>{ if(input.value==="--:--") input.value=""; });
  input.addEventListener("blur",()=>{ if(input.value==="") input.value="--:--"; });
  input.addEventListener("input",()=>{ let val=input.value.replace(/\D/g,'').slice(0,4); if(val.length>2) val=val.slice(0,2)+":"+val.slice(2); input.value=val; });
}

function initTrackName(trackNameEl){
  const DEFAULT_TRACK_NAME = "Neue Strecke";
  trackNameEl.innerText = DEFAULT_TRACK_NAME;

  trackNameEl.addEventListener("focus", () => {
    if(trackNameEl.innerText === DEFAULT_TRACK_NAME){
      trackNameEl.innerText = "";
      const range = document.createRange();
      const sel = window.getSelection();
      range.setStart(trackNameEl, 0);
      range.collapse(true);
      sel.removeAllRanges();
      sel.addRange(range);
    }
  });

  trackNameEl.addEventListener("blur", () => {
    if(trackNameEl.innerText.trim() === "") trackNameEl.innerText = DEFAULT_TRACK_NAME;
    if(trackNameEl.parentElement.trackObj) {
      trackNameEl.parentElement.trackObj.name = trackNameEl.innerText.trim();
    }
  });

  trackNameEl.addEventListener("keydown", (e) => {
    if(e.key === "Enter") {
      e.preventDefault();
      trackNameEl.blur();
    }
  });

  trackNameEl.addEventListener("input", () => {
    if(trackNameEl.parentElement.trackObj) {
      trackNameEl.parentElement.trackObj.name = trackNameEl.innerText.trim();
    }
  });
}

function addTrackForm() {
  const trackList = document.getElementById("trackList");
  const trackDiv = document.createElement("div");
  trackDiv.className = "track";

  const existingTracks = trackList.querySelectorAll(".track");
  const color = predefinedColors[existingTracks.length % predefinedColors.length];

  trackDiv.innerHTML = `
    <div class="track-header">
      <span class="toggleSymbol">▼</span>
      <span class="trackName" contenteditable="true">Neue Strecke</span>
      <div class="colorIndicator" style="background:${color}"></div>
      <button class="deleteTrackBtn">✕</button>
    </div>
    <div class="track-body">
      <label>Trackfarbe: <input type="color" class="trackColor" value="${color}"></label>
      <label>GPX-Datei: <input type="file" class="fileInput" accept=".gpx"></label>
      <label>Startzeit: <input type="time" class="startTime"></label>
      <label>Zielzeit: <input type="time" class="endTime"></label>
      <label>Schnellste Pace (min/km): <input type="text" class="fastPace" maxlength="5"></label>
      <label>Langsamste Pace (min/km): <input type="text" class="slowPace" maxlength="5"></label>
      <button class="loadBtn">Track laden</button>
      <button class="resetBtn">Reset</button>
    </div>
  `;

  trackList.appendChild(trackDiv);

  const header = trackDiv.querySelector(".track-header");
  const body = trackDiv.querySelector(".track-body");
  const toggle = header.querySelector(".toggleSymbol");
  const deleteBtn = header.querySelector(".deleteTrackBtn");
  const colorPicker = trackDiv.querySelector(".trackColor");
  const colorIndicator = trackDiv.querySelector(".colorIndicator");
  const trackNameEl = trackDiv.querySelector(".trackName");

  initTrackName(trackNameEl);
  initPaceField(trackDiv.querySelector(".fastPace"));
  initPaceField(trackDiv.querySelector(".slowPace"));

  toggle.addEventListener("click", (e) => {
    e.stopPropagation();
    const isOpen = trackDiv.classList.toggle("open");
    body.style.display = isOpen ? "block" : "none";
    toggle.innerHTML = isOpen ? "▼" : "▶";
  });

  trackDiv.classList.add("open");
  body.style.display = "block";

  deleteBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    if (trackDiv.trackObj) {
      ["fullTrackLayer","redSegment","fastMarker","slowMarker"].forEach(k => {
        if(trackDiv.trackObj[k]) map.removeLayer(trackDiv.trackObj[k]);
      });
      tracks = tracks.filter(t => t.id !== trackDiv.trackObj.id);
    }
    trackDiv.remove();
    updateSliderRange();

    const allTracks = document.querySelectorAll("#trackList .track");
    allTracks.forEach((div,i) => {
      const newColor = predefinedColors[i % predefinedColors.length];
      const cp = div.querySelector(".trackColor");
      const ci = div.querySelector(".colorIndicator");
      cp.value = newColor;
      ci.style.background = newColor;
      if(div.trackObj) {
        div.trackObj.color = newColor;
        if(div.trackObj.fullTrackLayer) div.trackObj.fullTrackLayer.setStyle({color:newColor});
      }
    });
  });

  colorPicker.addEventListener("input", () => {
    colorIndicator.style.background = colorPicker.value;
    if(trackDiv.trackObj?.fullTrackLayer) trackDiv.trackObj.fullTrackLayer.setStyle({color: colorPicker.value});
  });

  trackDiv.querySelector(".loadBtn").addEventListener("click", () => {
    const loadBtn = trackDiv.querySelector(".loadBtn");
    loadBtn.classList.add("loading");
    loadTrack(trackDiv);
    setTimeout(() => {
      loadBtn.classList.remove("loading");
    }, 1000);
  });

  trackDiv.querySelector(".resetBtn").addEventListener("click", () => {
    trackDiv.querySelector(".startTime").value = "";
    trackDiv.querySelector(".endTime").value = "";
    trackDiv.querySelector(".fastPace").value = "--:--";
    trackDiv.querySelector(".slowPace").value = "--:--";

    if(trackDiv.trackObj) {
      trackDiv.trackObj.startTime = null;
      trackDiv.trackObj.endTime = null;
      trackDiv.trackObj.fastSpeed = null;
      trackDiv.trackObj.slowSpeed = null;
      ["fullTrackLayer","redSegment","fastMarker","slowMarker"].forEach(k => {
        if(trackDiv.trackObj[k]) {
          map.removeLayer(trackDiv.trackObj[k]);
          trackDiv.trackObj[k] = null;
        }
      });
    }
    updateSliderRange();
  });
}

function loadTrack(trackDiv) {
  const existingTracks = document.querySelectorAll("#trackList .track");
  const trackIndex = existingTracks.length;
  const OFFSET_METERS = 10;
  const offsetAngle = (trackIndex - 1) * 30;

  const dLat = (OFFSET_METERS / 111320) * Math.cos(offsetAngle * Math.PI / 180);
  const dLng = (OFFSET_METERS / (111320 * Math.cos(49.9 * Math.PI / 180))) * Math.sin(offsetAngle * Math.PI / 180);

  const file = trackDiv.querySelector(".fileInput").files[0];
  if (!file) return alert("Bitte GPX-Datei auswählen.");

  const MAX_SIZE = 2 * 1024 * 1024;
  if (file.size > MAX_SIZE) {
    alert("Die Datei ist zu groß. Bitte wähle eine GPX-Datei bis maximal 2 MB.");
    return;
  }

  const color = trackDiv.querySelector(".trackColor").value;
  const reader = new FileReader();

  reader.onload = e => {
    const gpxText = e.target.result;
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(gpxText, "text/xml");

    let nodes = xmlDoc.getElementsByTagName("trkpt");
    if (!nodes || nodes.length === 0) nodes = xmlDoc.getElementsByTagName("rtept");
    if (!nodes || nodes.length === 0) {
      alert("Keine Trackpunkte gefunden (trkpt/rtept).");
      return;
    }

    const latlngs = Array.from(nodes).map(n =>
      L.latLng(
        parseFloat(n.getAttribute("lat")) + dLat,
        parseFloat(n.getAttribute("lon")) + dLng
      )
    );

    if (latlngs.length === 0) {
      alert("Keine gültigen Koordinaten in der GPX-Datei.");
      return;
    }

    const fastPaceVal = trackDiv.querySelector(".fastPace").value;
    const slowPaceVal = trackDiv.querySelector(".slowPace").value;

    const trackObj = {
      id: Date.now() + Math.random(),
      trackPoints: latlngs,
      totalDist: totalLength(latlngs),
      color: color,
      startTime: trackDiv.querySelector(".startTime").value || null,
      endTime: trackDiv.querySelector(".endTime").value || null,
      fastSpeed: fastPaceVal && fastPaceVal !== "--:--" ? paceToMetersPerMinute(fastPaceVal) : null,
      slowSpeed: slowPaceVal && slowPaceVal !== "--:--" ? paceToMetersPerMinute(slowPaceVal) : null
    };

    trackObj.fullTrackLayer = L.polyline(latlngs, { color, weight: 4 }).addTo(map);
    trackObj.fastMarker = L.marker(latlngs[0], { icon: fastRunnerIcon }).addTo(map);
    trackObj.slowMarker = L.marker(latlngs[0], { icon: slowRunnerIcon }).addTo(map);

    trackDiv.trackObj = trackObj;
    trackObj.name = trackDiv.querySelector(".trackName").innerText.trim();
    trackDiv.querySelector(".trackName").dataset.trackId = trackObj.id;

    tracks.push(trackObj);
    updateSliderRange();
    map.fitBounds(trackObj.fullTrackLayer.getBounds());
  };

  reader.readAsText(file);
}

document.getElementById("addTrackBtn").addEventListener("click",addTrackForm);

// Hamburger Menu Funktionalität - NACH Map initialisierung
document.addEventListener("DOMContentLoaded", () => {
  const hamburger = document.getElementById("hamburger");
  const sidebar = document.getElementById("sidebar");

  if(hamburger && sidebar) {
    hamburger.addEventListener("click", (e) => {
      e.stopPropagation();
      sidebar.classList.toggle("open");
    });

    // Sidebar schließen nur wenn auf die Karte klickt wird (nicht auf Sidebar)
    document.getElementById("map").addEventListener("click", () => {
      if(window.innerWidth <= 1024) {
        sidebar.classList.remove("open");
      }
    });
  }
});
</script>
</body>
</html>
