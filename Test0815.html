<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Brauereienlauf - Streckensimulator</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="/brauereienlauf/icons/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
body { margin:0; font-family:sans-serif; display:flex; height:100vh; overflow:hidden; }
#sidebar { width:300px; background:#FCF6EE; color:#333; padding:10px; box-shadow:2px 0 5px rgba(0,0,0,0.1); display:flex; flex-direction:column; gap:10px; overflow-y:auto; z-index:1000; }
#sidebarLogo { background:#212121; text-align:center; margin-bottom:10px; padding:10px; }
#sidebarLogo img { max-width:80%; height:auto; display:block; margin:0 auto; }
.track-header { display:flex; align-items:center; cursor:default; padding:6px 10px; font-weight:bold; background:#DED0BA; border-bottom:1px solid #ccc; user-select:none; gap:5px; border-radius:6px; color:#000; }
.track-header .toggleSymbol { color:#000; }
.track-header:hover { background:#7664AA; }
.track-header:hover .toggleSymbol { color:#fff; }
.track-header:hover .trackName:not(:focus) { color:#fff; }
.trackName { flex:1; padding:2px 4px; border-radius:4px; background:transparent; color:#000; }
.trackName:focus { background:white; color:#000; outline:2px solid #FF6600; }
.colorIndicator { width:20px; height:20px; border-radius:4px; border:1px solid #999; margin-left:5px; }
button { background:#FF6600; color:white; border:none; border-radius:4px; padding:6px 10px; cursor:pointer; margin-top:6px; }
button:hover { background:#cc5200; }
.track-body { display:none; padding:8px 10px; }
.track-body label { display:block; font-size:13px; margin-top:4px; }
input[type="file"], input[type="time"], input[type="text"], input[type="color"] { width:100%; }
#map { flex:1; position:relative; z-index:0; }
#sliderContainer { position:absolute; bottom:0; left:321px; right:0; background:#fff; padding:10px; box-shadow:0 -2px 5px rgba(0,0,0,0.1); display:flex; align-items:center; gap:10px; z-index:2000; }
#timeLabel { min-width:80px; font-weight:bold; }
</style>
</head>
<body>

<div id="sidebar">
  <div id="sidebarLogo"><img src="icons/brauereienlauf-sued-logo.svg" alt="Brauereienlauf Logo"></div>
  <button id="addTrackBtn">Weitere Strecke hinzufügen</button>
  <div id="trackList"></div>
</div>

<div id="map"></div>

<div id="sliderContainer" style="display:none;">
  <input type="range" id="timeSlider" step="1" value="0" style="flex:1;">
  <span id="timeLabel">0:00</span>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<!-- Leaflet-GPX wird nicht mehr benötigt / nicht eingebunden, wir parsen GPX manuell -->

<script>
// --- Karte ---
const map = L.map('map').setView([49.9, 11.0],12);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ maxZoom:19, attribution:'© OpenStreetMap-Mitwirkende' }).addTo(map);

// --- POIs ---
const pois = [
  { name:"Start und Ziel", coords:[49.91086414586559,11.008078342287886], description:"Start und Zielbereich Tanzwiesen Litzendorf" },
  { name:"Brauerei Knoblach", coords:[49.92612562825621,11.006192497921718], description:"VP Brauerei Knoblach" },
  { name:"Brauerei Hölzlein", coords:[49.916433164362154,11.044922412182059], description:"VP Brauerei Hölzlein" },
  { name:"Brauerei Hönig", coords:[49.91854570624229,11.074094351945764], description:"VP Brauerei Hönig" },
  { name:"Brauerei Reh", coords:[49.9161925538902,11.050437379307478], description:"VP Brauerei Reh" },
  { name:"Brauerei Brandholz", coords:[49.89962613596553,11.031593469565935], description:"VP Brauerei Brandholz" },
  { name:"Landgasthof Büttel", coords:[49.88168405246902,11.01294568627889], description:"VP Landgasthof Büttel" },
  { name:"Gasthof Schiller", coords:[49.85771626727418,11.005281650520448], description:"VP Gasthof Schiller" },
  { name:"Schwanenkeller", coords:[49.851879458949746,10.97576017952508], description:"VP Schwanenkeller" },
  { name:"Brauerei Sauer", coords:[49.867831104839176,10.996951685705579], description:"VP Brauerei Sauer" },
  { name:"Regnitztaler Alm", coords:[49.8881946385972,10.980967912301045], description:"VP Regnitztaler Alm" },
  { name:"Kunigundenruh", coords:[49.903828616877256,10.960579372597097], description:"VP Kunigundenruh" }
];

const poiIcon = L.icon({
  iconUrl: "icons/brauereienlauf_gestaltungselemente_maennchen_orange_rgb.svg",
  iconSize: [32,32],
  iconAnchor: [16,32],
  popupAnchor: [0,-32]
});

// --- Tracks ---
let tracks=[];
const predefinedColors=["#36542C","#FF6600","#7664AA","#212121","#DED0BA"];
let colorIndex=0;

// --- Slider ---
const slider=document.getElementById("timeSlider");
const timeLabel=document.getElementById("timeLabel");

// --- Helper ---
function parsePace(p){
  if(!p || p === "--:--") return null;
  const parts = p.split(":").map(Number);
  if(parts.length === 1) return parts[0]*60;
  const [m,s] = parts;
  return m*60 + (isNaN(s)?0:s);
}
function paceToMetersPerMinute(p){ const sec=parsePace(p); if(sec===null||sec===0) return null; return 1000/(sec/60); } // m/min
function totalLength(latlngs){ let d=0; for(let i=1;i<latlngs.length;i++) d+=latlngs[i-1].distanceTo(latlngs[i]); return d; }
function interpolatePoint(latlngs,f){
  if(!latlngs || latlngs.length===0) return null;
  if(f<=0) return latlngs[0];
  if(f>=1) return latlngs[latlngs.length-1];
  const total=totalLength(latlngs);
  if(total===0) return latlngs[0];
  const target=total*f;
  let dist=0;
  for (let i=1;i<latlngs.length;i++){
    const seg=latlngs[i-1].distanceTo(latlngs[i]);
    if(dist+seg>=target){
      const r=(target-dist)/seg;
      return L.latLng(
        latlngs[i-1].lat + (latlngs[i].lat - latlngs[i-1].lat)*r,
        latlngs[i-1].lng + (latlngs[i].lng - latlngs[i-1].lng)*r
      );
    }
    dist+=seg;
  }
  return latlngs[latlngs.length-1];
}
function getSubsegment(latlngs,startFrac,endFrac){
  if(!latlngs || latlngs.length===0) return [];
  const total=totalLength(latlngs);
  if(total===0) return [latlngs[0]];
  const startT=total*startFrac;
  const endT=total*endFrac;
  let dist=0;
  const pts=[];
  let startAdded=false;
  for(let i=1;i<latlngs.length;i++){
    const seg=latlngs[i-1].distanceTo(latlngs[i]);
    const segStart=dist;
    const segEnd=dist+seg;
    if(!startAdded && segEnd>=startT){
      const r=(startT-segStart)/seg;
      pts.push(L.latLng(
        latlngs[i-1].lat + (latlngs[i].lat - latlngs[i-1].lat)*r,
        latlngs[i-1].lng + (latlngs[i].lng - latlngs[i-1].lng)*r
      ));
      startAdded=true;
    }
    if(segEnd>startT && segStart<endT) pts.push(latlngs[i]);
    if(segEnd>=endT){
      const r=(endT-segStart)/seg;
      pts.push(L.latLng(
        latlngs[i-1].lat + (latlngs[i].lat - latlngs[i-1].lat)*r,
        latlngs[i-1].lng + (latlngs[i].lng - latlngs[i-1].lng)*r
      ));
      break;
    }
    dist+=seg;
  }
  return pts;
}
function timeToMinutes(t){ if(!t) return null; const [h,m]=t.split(":").map(Number); return h*60+m; }
function minutesToTime(m){ const h=Math.floor(m/60); const mm=m%60; return `${h.toString().padStart(2,'0')}:${mm.toString().padStart(2,'0')}`; }

// --- POI Popup ---
function showDistancesToPoi(poi, marker) {
  const poiLatLng = L.latLng(poi.coords);
  let info = `<b>${poi.name}</b><br>${poi.description}<hr>`;
  let hasRunner = false;

  tracks.forEach(track => {
    if (!track.trackPoints || !track.startTime || !track.endTime || !track.fastSpeed || !track.slowSpeed) return;

    let closestDist = Infinity;
    let distAlongTrack = 0;
    let distSoFar = 0;
    for(let i=1;i<track.trackPoints.length;i++){
      const p1=track.trackPoints[i-1], p2=track.trackPoints[i], segDist=p1.distanceTo(p2);
      // projektion wäre präziser, aber einfacher: min distance to endpoints of segment
      const d1 = p1.distanceTo(poiLatLng);
      const d2 = p2.distanceTo(poiLatLng);
      const minDist = Math.min(d1,d2);
      if(minDist < closestDist){
        closestDist=minDist;
        distAlongTrack = distSoFar + (minDist===d1?0:segDist);
      }
      distSoFar+=segDist;
    }

    if(closestDist>30) return;
    hasRunner=true;

    const tStart = timeToMinutes(track.startTime);
    const fastArrival = minutesToTime(Math.floor(tStart + distAlongTrack / track.fastSpeed));
    const slowArrival = minutesToTime(Math.floor(tStart + distAlongTrack / track.slowSpeed));

    info += `<b>${track.name||"Unbenannte Strecke"}</b><br>`;
    info += `Erster Läufer: ${fastArrival} Uhr<br>`;
    info += `Letzter Läufer: ${slowArrival} Uhr<br><br>`;
  });

  if(!hasRunner) info+="Keine Strecke führt hier vorbei.";

  if(!marker._popup) marker._popup=L.popup({maxWidth:250});
  marker._popup.setLatLng(marker.getLatLng()).setContent(info).openOn(map);
}

// --- POI Marker setzen ---
pois.forEach(poi => {
  const marker = L.marker(poi.coords, { icon: poiIcon }).addTo(map);
  marker.bindTooltip(poi.name);
  marker.on("click", () => showDistancesToPoi(poi, marker));
});

// --- Slider & Marker ---
function updateSliderRange(){
  const validTracks=tracks.filter(t=>t.startTime && t.endTime);
  if(validTracks.length===0){ document.getElementById("sliderContainer").style.display="none"; return; }
  const startTimes=validTracks.map(t=>timeToMinutes(t.startTime));
  const endTimes=validTracks.map(t=>timeToMinutes(t.endTime));
  slider.min=Math.min(...startTimes);
  slider.max=Math.max(...endTimes);
  slider.value=slider.min;
  timeLabel.innerText=minutesToTime(slider.value);
  document.getElementById("sliderContainer").style.display="flex";
  updateMarkers();
}
let animationFrame=null;
slider.addEventListener("input",()=>{ if(animationFrame) cancelAnimationFrame(animationFrame); animationFrame=requestAnimationFrame(updateMarkers); });

function updateMarkers(){
  const currentMin=Number(slider.value);
  timeLabel.innerText=minutesToTime(currentMin);

  tracks.forEach(track=>{
    if(!track.trackPoints || !track.startTime || !track.endTime || !track.fastSpeed || !track.slowSpeed){
      ["fastMarker","slowMarker","redSegment"].forEach(k=>{ if(track[k]) { map.removeLayer(track[k]); track[k]=null; } });
      return;
    }
    const minsSinceStart=currentMin-timeToMinutes(track.startTime);
    const fastDist=Math.max(Math.min(track.fastSpeed*minsSinceStart,track.totalDist),0);
    const slowDist=Math.max(Math.min(track.slowSpeed*minsSinceStart,track.totalDist),0);
    const fastFrac= track.totalDist>0 ? fastDist/track.totalDist : 0;
    const slowFrac= track.totalDist>0 ? slowDist/track.totalDist : 0;

    const fastPos=interpolatePoint(track.trackPoints,fastFrac);
    const slowPos=interpolatePoint(track.trackPoints,slowFrac);

    if(track.fastMarker) track.fastMarker.setLatLng(fastPos);
    if(track.slowMarker) track.slowMarker.setLatLng(slowPos);

    if(track.redSegment) { map.removeLayer(track.redSegment); track.redSegment=null; }
    const subPoints=getSubsegment(track.trackPoints,Math.min(fastFrac,slowFrac),Math.max(fastFrac,slowFrac));
    if(subPoints.length>0) track.redSegment=L.polyline(subPoints,{color:"red",weight:6}).addTo(map);
  });
}

// --- Pace Mask ---
function initPaceField(input){
  input.value="--:--";
  input.addEventListener("focus",()=>{ if(input.value==="--:--") input.value=""; });
  input.addEventListener("blur",()=>{ if(input.value==="") input.value="--:--"; });
  input.addEventListener("input",()=>{
    let val=input.value.replace(/\D/g,'').slice(0,4);
    if(val.length>2) val=val.slice(0,2)+":"+val.slice(2);
    input.value=val;
  });
}

// --- Track hinzufügen / laden ---
function addTrackForm(){
  const trackList = document.getElementById("trackList");
  const trackDiv = document.createElement("div");
  trackDiv.className = "track";

  // Neue Farbvergabe basierend auf aktueller Reihenfolge
  const existingTracks = trackList.querySelectorAll(".track");
  const color = predefinedColors[existingTracks.length % predefinedColors.length];

  trackDiv.innerHTML = `
    <div class="track-header">
      <span class="toggleSymbol">&#9654;</span>
      <span class="trackName" contenteditable="true">Neue Strecke</span>
      <div class="colorIndicator" style="background:${color}"></div>
      <button class="deleteTrackBtn">X</button>
    </div>
    <div class="track-body">
      <label>Trackfarbe: <input type="color" class="trackColor" value="${color}"></label>
      <label>GPX-Datei: <input type="file" class="fileInput" accept=".gpx"></label>
      <label>Startzeit: <input type="time" class="startTime"></label>
      <label>Zielzeit: <input type="time" class="endTime"></label>
      <label>Schnellste Pace (min/km): <input type="text" class="fastPace" maxlength="5"></label>
      <label>Langsamste Pace (min/km): <input type="text" class="slowPace" maxlength="5"></label>
      <button class="loadBtn">Track laden</button>
      <button class="resetBtn">Reset</button>
    </div>
  `;

  trackList.appendChild(trackDiv);

  const header = trackDiv.querySelector(".track-header");
  const body = trackDiv.querySelector(".track-body");
  const toggle = header.querySelector(".toggleSymbol");
  const deleteBtn = header.querySelector(".deleteTrackBtn");
  const colorPicker = trackDiv.querySelector(".trackColor");
  const colorIndicator = trackDiv.querySelector(".colorIndicator");

  initPaceField(trackDiv.querySelector(".fastPace"));
  initPaceField(trackDiv.querySelector(".slowPace"));

  header.addEventListener("click",()=>{ const open=body.style.display==="block"; body.style.display=open?"none":"block"; toggle.innerHTML=open?"&#9654;":"&#9660;"; });

// Löschen-Button
deleteBtn.addEventListener("click", (e) => {
  e.stopPropagation();

  if (trackDiv.trackObj) {
    // Alle Layer von der Karte entfernen
    ["fullTrackLayer", "redSegment", "fastMarker", "slowMarker", "gpxLayer"].forEach(key => {
      if (trackDiv.trackObj[key]) map.removeLayer(trackDiv.trackObj[key]);
    });

    // Track aus globalem Array entfernen
    tracks = tracks.filter(t => t.id !== trackDiv.trackObj.id);
  }

  trackDiv.remove();
  updateSliderRange();

  // --- Farben nach Löschung neu zuordnen ---
  const allTracks = document.querySelectorAll("#trackList .track");
  allTracks.forEach((div, i) => {
    const newColor = predefinedColors[i % predefinedColors.length];
    const colorPicker = div.querySelector(".trackColor");
    const colorIndicator = div.querySelector(".colorIndicator");
    colorPicker.value = newColor;
    colorIndicator.style.background = newColor;

    // Falls Track schon geladen ist: Farbe in der Karte & im Objekt anpassen
    if (div.trackObj) {
      div.trackObj.color = newColor;
      if (div.trackObj.fullTrackLayer) div.trackObj.fullTrackLayer.setStyle({ color: newColor });
    }
  });
});


  colorPicker.addEventListener("input",()=>{ colorIndicator.style.background=colorPicker.value; if(trackDiv.trackObj?.fullTrackLayer) trackDiv.trackObj.fullTrackLayer.setStyle({color:colorPicker.value}); });

  trackDiv.querySelector(".loadBtn").addEventListener("click",()=>loadTrack(trackDiv));
  trackDiv.querySelector(".resetBtn").addEventListener("click",()=>{
    trackDiv.querySelector(".startTime").value="";
    trackDiv.querySelector(".endTime").value="";
    trackDiv.querySelector(".fastPace").value="--:--";
    trackDiv.querySelector(".slowPace").value="--:--";
    if(trackDiv.trackObj){
      trackDiv.trackObj.startTime=null;
      trackDiv.trackObj.endTime=null;
      trackDiv.trackObj.fastSpeed=null;
      trackDiv.trackObj.slowSpeed=null;
      ["fullTrackLayer","redSegment","fastMarker","slowMarker"].forEach(key=>{
        if(trackDiv.trackObj[key]) { map.removeLayer(trackDiv.trackObj[key]); trackDiv.trackObj[key]=null; }
      });
    }
    updateSliderRange();
  });
}

// --- GPX manuell parsen & Track laden (kein Leaflet-GPX) ---
function loadTrack(trackDiv){
  const file = trackDiv.querySelector(".fileInput").files[0];
  if(!file) return alert("Bitte GPX-Datei auswählen.");
  const color = trackDiv.querySelector(".trackColor").value;
  const reader = new FileReader();

  reader.onload = e => {
    const gpxText = e.target.result;
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(gpxText, "text/xml");

    // trkpt bevorzugen, fallback auf rtept
    let nodes = xmlDoc.getElementsByTagName("trkpt");
    if(!nodes || nodes.length === 0) nodes = xmlDoc.getElementsByTagName("rtept");
    if(!nodes || nodes.length === 0){
      alert("Keine Trackpunkte gefunden (trkpt/rtept).");
      return;
    }

    // Erzeuge LatLng-Array (L.latLng-Objekte)
    const latlngs = Array.from(nodes).map(n => L.latLng(parseFloat(n.getAttribute("lat")), parseFloat(n.getAttribute("lon"))));

    if(latlngs.length === 0){
      alert("Keine gültigen Koordinaten in der GPX-Datei.");
      return;
    }

    const fastPaceVal = trackDiv.querySelector(".fastPace").value;
    const slowPaceVal = trackDiv.querySelector(".slowPace").value;

    const trackObj = {
      id: Date.now() + Math.random(),
      trackPoints: latlngs,
      totalDist: totalLength(latlngs),
      color: color,
      startTime: trackDiv.querySelector(".startTime").value || null,
      endTime: trackDiv.querySelector(".endTime").value || null,
      fastSpeed: fastPaceVal && fastPaceVal!=="--:--"? paceToMetersPerMinute(fastPaceVal) : null,
      slowSpeed: slowPaceVal && slowPaceVal!=="--:--"? paceToMetersPerMinute(slowPaceVal) : null
      // kein gpxLayer mehr nötig
    };

    // Volle Linie + Marker (nur unsere eigenen Layer)
    trackObj.fullTrackLayer = L.polyline(latlngs,{color,weight:4}).addTo(map);
    trackObj.fastMarker = L.circleMarker(latlngs[0],{radius:7,color:'green'}).addTo(map);
    trackObj.slowMarker = L.circleMarker(latlngs[0],{radius:7,color:'red'}).addTo(map);

    trackDiv.trackObj = trackObj;
    trackObj.name = trackDiv.querySelector(".trackName").innerText.trim();
    trackDiv.querySelector(".trackName").dataset.trackId = trackObj.id;

    tracks.push(trackObj);
    updateSliderRange();
    map.fitBounds(trackObj.fullTrackLayer.getBounds());
  };

  reader.readAsText(file);
}

document.getElementById("addTrackBtn").addEventListener("click",addTrackForm);
</script>
</body>

</html>



